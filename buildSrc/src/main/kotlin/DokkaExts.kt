/*
 * Copyright 2025, TeamDev. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Redistribution and use in source and/or binary forms, with or without
 * modification, must retain the above copyright notice and the following
 * disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import io.spine.dependency.build.Dokka
import io.spine.gradle.publish.getOrCreate
import java.io.File
import java.time.LocalDate
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Dependency
import org.gradle.api.artifacts.dsl.DependencyHandler
import org.gradle.api.tasks.TaskContainer
import org.gradle.api.tasks.TaskProvider
import org.gradle.api.tasks.bundling.Jar
import org.gradle.kotlin.dsl.DependencyHandlerScope
import org.jetbrains.dokka.gradle.DokkaExtension
import org.jetbrains.dokka.gradle.engine.parameters.DokkaSourceSetSpec
import org.jetbrains.dokka.gradle.engine.parameters.VisibilityModifier
import org.jetbrains.dokka.gradle.engine.plugins.DokkaHtmlPluginParameters

/**
 * To exclude pieces of code annotated with `@Internal` from the documentation
 * a custom plugin is added to the Dokka classpath.
 *
 * @see <a href="https://github.com/SpineEventEngine/dokka-tools/tree/master/dokka-extensions">
 *     Custom Dokka Plugins</a>
 */
fun DependencyHandlerScope.useDokkaWithSpineExtensions() {
    dokkaPlugin(Dokka.SpineExtensions.lib)
}

private fun DependencyHandler.dokkaPlugin(dependencyNotation: Any): Dependency? =
    add("dokkaPlugin", dependencyNotation)

/**
 * Resolves the directory where Dokka outputs HTML documentation for the given language.
 */
internal fun Project.dokkaHtmlOutput(): File {
    return layout.buildDirectory.dir("dokka/html").get().asFile
}

/**
 * Locates a Dokka configuration file under the `buildSrc` resources.
 */
fun Project.dokkaConfigFile(file: String): File {
    val dokkaConfDir = project.rootDir.resolve("buildSrc/src/main/resources/dokka")
    return dokkaConfDir.resolve(file)
}

/**
 * Configures the presentation style, logo, and footer message.
 *
 * Dokka Base plugin allows setting a few properties to customize the output:
 * - `customStyleSheets` property to which CSS files are passed overriding
 *  styles generated by Dokka;
 * - `customAssets` property to provide resources. The image with the name
 *  "logo-icon.svg" is passed to override the default logo used by Dokka;
 * - `separateInheritedMembers` when set to `true`, creates a separate tab in
 *  type-documentation for inherited members.
 *
 * @see <a href="https://kotlin.github.io/dokka/1.8.10/user_guide/base-specific/frontend/#prerequisites">
 *  Dokka modifying frontend assets</a>
 */
fun DokkaHtmlPluginParameters.configureStyle(project: Project) {
    customAssets.from(project.dokkaConfigFile("assets/logo-icon.svg"))
    customStyleSheets.from(project.dokkaConfigFile("styles/custom-styles.css"))
    footerMessage.set("Copyright ${LocalDate.now().year}, TeamDev")
    separateInheritedMembers.set(true)
    mergeImplicitExpectActualDeclarations.set(false)
}

private fun DokkaExtension.configureFor(
    project: Project,
    language: String,
    sourceLinkRemoteUrl: String
) {
    dokkaPublications.named("html").configure {
        suppressInheritedMembers.set(true)
        failOnWarning.set(true)
    }

    val commonMain = "commonMain"
    val jvmMain = "jvmMain"

    val commonMainDir = project.file("src/$commonMain")
    val jvmMainDir = project.file("src/$jvmMain")
    val isKmp = commonMainDir.exists() || jvmMainDir.exists()

    if (isKmp) {
        if (commonMainDir.exists()) {
            dokkaSourceSets.named(commonMain).configure {
                configureSourceSet(
                    SourceSetConfig(commonMainDir, sourceLinkRemoteUrl)
                )
            }
        }

        if (jvmMainDir.exists()) {
            dokkaSourceSets.named(jvmMain).configure {
                configureSourceSet(
                    SourceSetConfig(jvmMainDir, sourceLinkRemoteUrl, null)
                )
            }
        }
    } else {
        dokkaSourceSets.named("main").configure {
            configureSourceSet(
                SourceSetConfig(
                    sourceDir = project.file("src/main/${language.lowercase()}"),
                    sourceLinkRemoteUrl = sourceLinkRemoteUrl,
                )
            )
        }
    }

    pluginsConfiguration.named("html").configure { this as DokkaHtmlPluginParameters
        configureStyle(project)
    }
}

private data class SourceSetConfig(
    val sourceDir: File,
    val sourceLinkRemoteUrl: String,
    val moduleDoc: String? = "Module.md"
)

private fun DokkaSourceSetSpec.configureSourceSet(config: SourceSetConfig) {
    config.moduleDoc?.let { doc ->
        if (File(doc).exists()) {
            this@configureSourceSet.includes.from(doc)
        }
    }

    sourceLink {
        localDirectory.set(config.sourceDir)
        remoteUrl(config.sourceLinkRemoteUrl)
        remoteLineSuffix.set(DocumentationSettings.SourceLink.lineSuffix)
    }

    jdkVersion.set(BuildSettings.javaVersion.asInt())
    skipEmptyPackages.set(true)

    documentedVisibilities.set(
        setOf(
            VisibilityModifier.Public,
            VisibilityModifier.Protected
        )
    )
}

/**
 * Configures this [DokkaExtension] to accept only Kotlin files.
 */
fun DokkaExtension.configureForKotlin(project: Project, sourceLinkRemoteUrl: String) {
    configureFor(project, "kotlin", sourceLinkRemoteUrl)
}

/**
 * Configures this [DokkaExtension] to accept only Java files.
 */
@Suppress("unused")
fun DokkaExtension.configureForJava(project: Project, sourceLinkRemoteUrl: String) {
    configureFor(project, "java", sourceLinkRemoteUrl)
}

/**
 * Finds the `dokkaGenerateHtml` Gradle task.
 */
fun TaskContainer.dokkaHtmlTask(): Task? = this.findByName("dokkaGeneratePublicationHtml")

/**
 * Finds the `dokkaGeneratePublicationJavadoc` Gradle task.
 */
fun TaskContainer.dokkaJavadocTask(): Task? = this.findByName("dokkaGeneratePublicationJavadoc")

/**
 * Locates or creates `htmlDocsJar` task in this [Project].
 *
 * The output of this task is a `jar` archive. The archive contains the Dokka output, generated upon
 * Kotlin sources from `main` source set. Requires Dokka to be configured in the target project by
 * applying `dokka-setup` plugin.
 */
fun Project.htmlDocsJar(): TaskProvider<Jar> = tasks.getOrCreate("htmlDocsJar") {
    archiveClassifier.set("html-docs")
    from(files(dokkaHtmlOutput()))

    tasks.dokkaHtmlTask()?.let { dokkaTask ->
        this@getOrCreate.dependsOn(dokkaTask)
    }
}

/**
 * Tells if this task belongs to the execution graph which contains
 * the `publish` and `dokkaGenerate` tasks.
 *
 * This predicate could be useful for disabling publishing tasks
 * when doing, e.g., `publishToMavenLocal` for the purpose of the
 * integration tests that (of course) do not test the documentation
 * generation process and its results.
 */
fun Task.isInPublishingGraph(): Boolean =
    project.gradle.taskGraph.allTasks.any {
        it.name == "publish" || it.name.contains("dokkaGenerate")
    }

/**
 * Disables Dokka and Javadoc tasks in this `Project`.
 *
 * This function could be useful to improve build speed when building subprojects containing
 * test environments or integration test projects.
 */
@Suppress("unused")
fun Project.disableDocumentationTasks() {
    gradle.taskGraph.whenReady {
        tasks.forEach { task ->
            val lowercaseName = task.name.lowercase()
            if (lowercaseName.contains("dokka") || lowercaseName.contains("javadoc")) {
                task.enabled = false
            }
        }
    }
}
