import groovy.xml.MarkupBuilder
import org.gradle.api.internal.artifacts.dependencies.AbstractExternalModuleDependency

/**
 * This script generates a {@code pom.xml} file that contains dependencies of the root project as well as the
 * dependencies of its subprojects.
 *
 * The generated {@code pom.xml} is not usable for {@code maven} build tasks and is merely a description of project
 * dependencies.
 *
 * Configures the {@code build} task to generate the {@code pom.xml} file.
 *
 * Also configures the {@code clean} task to delete the generated {@code pom.xml} file.
 *
 * To generate the script, {@code apply} from this file.
 */

apply plugin: 'maven'

ext {
    outputFile = "$projectDir" + File.separator + "pom.xml"
}

task generatePom {
    doLast {
        ProjectPomXml result = new ProjectPomXml(project)
        result.writeTo(outputFile)
    }
}

build.finalizedBy generatePom

clean.doFirst {
    delete outputFile
}

/**
 * A {@code pom.xml} file that contains dependencies of the project and its subprojects.
 *
 * <p>It is not usable for {@code maven} build tasks and serves as a description of project first level dependencies,
 * i.e, transitive dependencies are not included
 */
class ProjectPomXml {

    private static final String XML_METADATA = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
    private static final String PROJECT_SCHEMA_LOCATION = "<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"" +
            "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">"
    private static final String MODEL_VERSION = "<modelVersion>4.0.0</modelVersion>"
    private static final String CLOSING_PROJECT_TAG = "</project>"
    private static final String SPINE_INCEPTION_YEAR = "2015"
    private static final String NEW_LINE = System.lineSeparator()

    private final Project project
    private final String artifactId
    private final String version

    ProjectPomXml(Project project) {
        this.project = project
        this.artifactId = project.name
        this.version = project.version
    }

    /**
     * Writes the {@code pom.xml} file containing dependencies of this project and its subprojects to the specified
     * location.
     *
     * <p>If a file with the specified location exists, it will not be rewritten and instead be appended with
     * {@code pom.xml} file contents.
     *
     * @param filePath path to write {@code pom.xml} file to
     */
    void writeTo(String filePath) {
        FileWriter fileWriter = new FileWriter(filePath, true)
        writeHeader(fileWriter)

        writeBlocks(fileWriter,
                describingComment(),
                rootProjectData(),
                inceptionYear(),
                licence(),
                projectDependencies()
        )
        fileWriter.close()
    }

    /**
     * Writes the specified lines using the specified writer, dividing them by platforms line
     * separator.
     *
     * The written lines are also padded with platforms line separator from both sides
     *
     * <p>Used writer will not be closed
     */
    void writeBlocks(FileWriter writer, String... lines) {
        writer.write(NEW_LINE)
        for (String line : lines) {
            writer.write(line)
            writer.write(NEW_LINE)
            writer.write(NEW_LINE)
        }
        writer.write(NEW_LINE)
    }
    /**
     * Obtains a String that represents a tag with the inception year of Spine.
     */
    private static String inceptionYear() {
        Writer writer = new StringWriter()
        MarkupBuilder xmlBuilder = new MarkupBuilder(writer)
        xmlBuilder.inceptionYear(SPINE_INCEPTION_YEAR)
        return writer.toString()
    }

    /**
     * Obtains licence information about Spine.
     *
     * <p>More on licences <a href="https://maven.apache.org/pom.html#Licenses">here</a>.
     */
    private static String licence() {
        Writer writer = new StringWriter()
        SpineLicenceAsXml.writeUsing(writer)
        return writer.toString()
    }

    /**
     * Obtains a string that contains project dependencies as XML.
     *
     * <p>Obtained string also contains a closing project tag.
     */
    private String projectDependencies() {
        Writer writer = new StringWriter()
        ProjectDependenciesAsXml projectDeps = ProjectDependenciesAsXml.of(project)
        projectDeps.writeUsing(writer)
        writer.write(NEW_LINE)
        writer.write(CLOSING_PROJECT_TAG)
        return writer.toString()
    }


    /**
     * Obtains a description comment that describes the nature of the generated {@code pom.xml} file.
     */
    private static String describingComment() {
        String description =
                System.lineSeparator() +
                        "This file was generated using the Gradle `generatePom` task. " +
                        System.lineSeparator() +
                        "This file is not suitable for `maven` build tasks. It only describes the " +
                        "first-level dependencies of " +
                        System.lineSeparator() +
                        "all modules and does not describe the project " +
                        "structure per-subproject." +
                        System.lineSeparator()
        String descriptionComment =
                String.format("<!-- %s %s %s -->",
                        System.lineSeparator(),
                        description,
                        System.lineSeparator())
        return descriptionComment
    }


    /**
     * Obtains a string that contains the name and the version of the current project.
     */
    private String rootProjectData() {
        Writer writer = new StringWriter()
        MarkupBuilder xmlBuilder = new MarkupBuilder(writer)
        xmlBuilder.artifactId(this.artifactId)
        xmlBuilder.version(this.version)
        return writer.toString()
    }

    /**
     * Writes the XML metadata using the specified writer.
     *
     * <p>Used writer will not be closed.
     */
    private static void writeHeader(FileWriter fileWriter) {
        fileWriter.write(XML_METADATA)
        fileWriter.write(System.lineSeparator())
        fileWriter.write(PROJECT_SCHEMA_LOCATION)
        fileWriter.write(System.lineSeparator())
        fileWriter.write(MODEL_VERSION)
        fileWriter.write(System.lineSeparator())
    }
}

/**
 * Dependencies of the project expressed as XML.
 *
 * <p>Subprojects dependencies are included, transitive dependencies are not included.
 *
 * <p>Example:
 * <pre>
 * {@code
 *  <dependencies>
 *      <dependency>
 *          <groupId>io.spine</groupId>
 *          <artifactId>base</artifactId>
 *          <version>1.0.0-pre7</version>
 *}
 * </pre>
 */
class ProjectDependenciesAsXml {

    private final Set<DependencyWithScope> firstLevelDependencies

    private ProjectDependenciesAsXml(Set<Dependency> dependencySet) {
        this.firstLevelDependencies = new HashSet<>(dependencySet)
    }

    /** Creates a new instance based on the specified project. */
    static ProjectDependenciesAsXml of(Project project) {
        Set<DependencyWithScope> dependencies = projectDependencies(project)
        return new ProjectDependenciesAsXml(dependencies)
    }

    /**
     * Writes the dependencies using the specified writer.
     *
     * <p>Used writer will not be closed.
     */
    void writeUsing(Writer writer) {
        MarkupBuilder xmlBuilder = new MarkupBuilder(writer)
        xmlBuilder.dependencies() {
            firstLevelDependencies.each { projectDep ->
                dependency {
                    groupId(projectDep.dependency().group)
                    artifactId(projectDep.dependency().name)
                    version(projectDep.dependency().version)
                    config(projectDep.configuration().name)
                    scope(projectDep.scope())
                }
            }
        }
    }

    private static Set<DependencyWithScope> projectDependencies(Project project) {
        Set<DependencyWithScope> firstLevelDependencies = new HashSet<>()
        project.subprojects.forEach { subproject ->
            Set<DependencyWithScope> subprojectDeps = dependenciesFromAllConfigurations(subproject)
            firstLevelDependencies.addAll(subprojectDeps)
        }
        return firstLevelDependencies
    }

    private static Set<DependencyWithScope> dependenciesFromAllConfigurations(Project project) {
        Set<DependencyWithScope> result = new HashSet<>()
        project.configurations.forEach { configuration ->
            configuration.dependencies.forEach {
                if (isExternal(it)) {
                    /* 
                       Note that despite using the `Set` data structure, `result` will still contain duplicates
                       and an additional check is necessary. 
                     */
                    DependencyWithScope dependency = DependencyWithScope.of(it, configuration)
                    addIfNotPresent(dependency, result)
                }
            }
        }
        return result
    }

    private static boolean isExternal(Dependency dependency) {
        return AbstractExternalModuleDependency.isAssignableFrom(dependency.class)
    }

    private static void addIfNotPresent(DependencyWithScope dependency,
                                        Set<DependencyWithScope> dependencySet) {
        boolean isDuplicate = dependencySet.stream()
                .anyMatch { dependenciesEqual(it, dependency) }
        if (!isDuplicate) {
            dependencySet.add(dependency)
        }
    }

    /**
     *  Returns whether the first specified dependency is equal to the second specified dependency.
     *
     *  <p>Comparison is performed based on the group ID, name and the version. If either of those
     *  criteria differs between specified dependencies, {@code false} is returned.
     */
    private static boolean dependenciesEqual(DependencyWithScope it, DependencyWithScope that) {
        Dependency firstDependency = it.dependency()
        Dependency secondDependency = that.dependency()

        boolean groupMatches = firstDependency.group.equals(secondDependency.group)
        boolean nameMatches = firstDependency.name.equals(secondDependency.name)
        boolean versionMatches = firstDependency.version.equals(secondDependency.version)
        return groupMatches && nameMatches && versionMatches
    }
}

/**
 * A project dependency with its scope.
 *
 * @see
 * <a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope">
 *     More on dependency scopes </a>.
 *
 */
class DependencyWithScope {

    private static Map<String, DependencyScope> KNOWN_SCOPES
    private final Dependency dependency
    private final DependencyScope scope
    private final Configuration tempConfig

    static {
        KNOWN_SCOPES = new HashMap<>()
        KNOWN_SCOPES.put("compile", DependencyScope.compile)
        KNOWN_SCOPES.put("implementation", DependencyScope.compile)
        KNOWN_SCOPES.put("api", DependencyScope.compile)
        KNOWN_SCOPES.put("runtime", DependencyScope.runtime)
    }

    private DependencyWithScope(Dependency dependency, DependencyScope scope, Configuration config) {
        this.dependency = dependency
        this.scope = scope
        this.tempConfig = config
    }

    static DependencyWithScope of(Dependency dependency, Configuration configuration) {
        String configurationName = configuration.name
        if (KNOWN_SCOPES.containsKey(configurationName)) {
            return new DependencyWithScope(dependency, KNOWN_SCOPES.get(configurationName), configuration)
        }
        if (configurationName.toLowerCase().startsWith("test")) {
            return new DependencyWithScope(dependency, DependencyScope.test, configuration)
        }
        // Fallback to compile.
        return new DependencyWithScope(dependency, DependencyScope.system, configuration)
    }

    Dependency dependency() {
        return this.dependency
    }

    DependencyScope scope() {
        return this.scope
    }

    Configuration configuration() {
        return this.tempConfig
    }

    static enum DependencyScope {
        compile,
        provided,
        runtime,
        test,
        system
        /*
            import is also a scope, however, it can't be used outside the `<dependencyManagement>`
            section, which is outside of the scope of this script
         */
    }
}


/**
 * Information about the licences used by Spine in XML form.
 */
class SpineLicenceAsXml {
    private static final String NAME = "Apache License, Version 2.0"
    private static final String URL = "https://www.apache.org/licenses/LICENSE-2.0.txt"
    private static final String DISTRIBUTION = "repo"

    /** Prevents instantiation. */
    private SpineLicenceAsXml() {
    }

    /**
     * Writes information about the Spine licence using the specified writer.
     */
    static void writeUsing(Writer fileWriter) {
        MarkupBuilder xmlBuilder = new MarkupBuilder(fileWriter)
        xmlBuilder.licenses {
            license {
                name(NAME)
                url(SpineLicenceAsXml.URL)
                distribution(DISTRIBUTION)
            }
        }
    }
}
